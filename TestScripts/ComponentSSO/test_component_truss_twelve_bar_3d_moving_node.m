%test_component_hollow_sphere Component solution spaces for a sphere problem 
%   test_component_hollow_sphere computes a component solution spaces with 
%   for a sphere problem.
%
%   Copyright 2024 Eduardo Rodrigues Della Noce
%   SPDX-License-Identifier: Apache-2.0

%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%   
%       http://www.apache.org/licenses/LICENSE-2.0
%   
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.


%% Cleanup
fclose all;
close all;
clear all;
clc;
more off;
diary off;


%% debugging
rng(4);


%% Documentation / Archive
rngState = rng;
saveFolder = save_diary_files(mfilename);
goldenRatio = (1+sqrt(5))/2;
figureSize = [goldenRatio 1]*8.5;


%% function call
%
systemFunction = @truss_twelve_bar_3d_moving_node;
systemParameter = [1000,210e3]; % [mm^2],[MPa]

%                         x1   y1   z1  x2   y2  z2  x3  y3   z3
designSpaceLowerBound = [0.5 -0.5 -0.5 0.5 -0.5 0.5 0.5 0.5 -0.5];
designSpaceUpperBound = [1.5  0.5  0.5 1.5  0.5 1.5 1.5 1.5  0.5];
Components = {[1,2,3]',[4,5,6]',[7,8,9]'};

%
performanceLowerLimit = 0;
performanceUpperLimit = [nan repmat(250,1,12)];

%                x1 y1 z1 x2 y2 z2 x3 y3 z3
initialDesign = [ 1  0  0  1  0  1  1  1  0];

RequirementSpacesType = 'Omega1';


%% find optimum
bottomUpMapping = BottomUpMappingFunction(systemFunction,systemParameter);

[nodePositionOptimal,displacementOptimal] = design_optimize_quantities_of_interest(...
    bottomUpMapping,...
    initialDesign,...
    designSpaceLowerBound,...
    designSpaceUpperBound,...
    @(performanceMeasure)[performanceMeasure(1)],...
    'InequalityConstraintFunction',@(performanceMeasure)[performanceMeasure(2:end)-250],...
    'OptimizationMethodOptions',{'Display','iter-detailed'});


%% Component Opt - Function
% update uppwer limit based on optimal value
performanceUpperLimit(1) = displacementOptimal*1.1;
designEvaluator = DesignEvaluatorBottomUpMapping(...
        bottomUpMapping,...
        performanceLowerLimit,...
        performanceUpperLimit);

tic
optionsBox = sso_stochastic_options('box',...
    'NumberSamplesPerIterationExploration',300,...
    'NumberSamplesPerIterationConsolidation',300,...
    'FixIterNumberExploration',true,...
    'FixIterNumberConsolidation',true,...
    'MaxIterExploration',30,...
    'MaxIterConsolidation',30,...
    'UseAdaptiveGrowthRate',false,...
    'GrowthRate',0.1,...
    'ApplyLeanness','never',...
    'TrimmingOperationOptions',{'PassesCriterion','full'},...
    'TrimmingOrderOptions',{'OrderPreference','score'});

[solutionSpaceBox,problemDataBox,iterDataBox] = sso_box_stochastic(designEvaluator,...
    nodePositionOptimal,designSpaceLowerBound,designSpaceUpperBound,optionsBox);
toc

tic
options = sso_stochastic_options('component',...
    'NumberSamplesPerIterationExploration',300,...
    'NumberSamplesPerIterationConsolidation',300,...
    'FixIterNumberExploration',true,...
    'FixIterNumberConsolidation',true,...
    'MaxIterExploration',30,...
    'MaxIterConsolidation',30,...
    'CandidateSpaceConstructorExploration',@CandidateSpaceConvexHull,...
    'CandidateSpaceConstructorConsolidation',@CandidateSpaceConvexHull,...
    'TrimmingMethodFunction',@component_trimming_method_planar_trimming,...
    'UseAdaptiveGrowthRate',false,...
    'GrowthRate',0.1,...
    'ApplyLeanness','never',...
    'UsePaddingSamplesInTrimming',true,...
    'UsePreviousEvaluatedSamplesConsolidation',false,...
    'UsePreviousPaddingSamplesConsolidation',false,...
    'TrimmingOperationOptions',{'PassesCriterion','reduced'},...
    'TrimmingOrderOptions',{'OrderPreference','score'});

[componentSolutionSpace,problemData,iterData] = sso_component_stochastic(designEvaluator,...
    nodePositionOptimal,designSpaceLowerBound,designSpaceUpperBound,Components,options);
toc


%% Plot Visualization
fixedDegreesOfFreedom = [...
    true true true; % (1) 
    true true true; % (2)
    true true true; % (3)
    false false false; % (4)
    false false false; % (5)
    false false false; % (6)
    false false false]; % (7)
nodeForce = [...
    0 0     0; % (1)
    0 0     0; % (2)
    0 0     0; % (3)
    0 0     0; % (4)
    0 0     0; % (5)
    0 0     0; % (6)
    0 0 -1000]; % (7)
nodeElement = [...
    1 4; % (1)
    2 5; % (2)
    3 6; % (3)
    1 5; % (4)
    3 4; % (5)
    3 5; % CONFIRM WITH ZM
    4 5; % (6)
    5 6; % (7)
    4 6; % (8)
    4 7; % (9)
    5 7; % (10)
    6 7]; % (11)
elementCrossSectionArea = systemParameter(1); % [mm^2]
elementYoungsModulus = systemParameter(2); % [MPa]

nodePositionInitial = [...
             0   0   0; % (1)
             0   0   1; % (2)
             0   1   0; % (3)
    initialDesign(1:3); % (4)
    initialDesign(4:6); % (5) 
    initialDesign(7:9); % (6)
             2 0.5 0.5]; % (7)

nodePositionOptimized = [...
                   0   0   0; % (1)
                   0   0   1; % (2)
                   0   1   0; % (3)
    nodePositionOptimal(1:3); % (4)
    nodePositionOptimal(4:6); % (5) 
    nodePositionOptimal(7:9); % (6)
                   2 0.5 0.5]; % (7)

[wallY,wallZ] = meshgrid(-0.5:1.5);
wallX = zeros(size(wallY));

figure;
hold all;
... handleInitial = plot_truss_deformation(gcf,nodePositionInitial,nodeElement);
handleOptimal = plot_truss_deformation(gcf,nodePositionOptimized,nodeElement,'ColorUndeformed','b','MaximumLinewidth',4.0);
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleToleranceNode1Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[1,2,3]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode2Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[4,5,6]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode3Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[7,8,9]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode1Component = componentSolutionSpace(1).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode2Component = componentSolutionSpace(2).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode3Component = componentSolutionSpace(3).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
grid minor;
legend([...
        ... handleInitial,...
        handleOptimal,...
        handleWall,...
        handleToleranceNode1Box,...
        handleToleranceNode1Component,...
        ... handleToleranceNode1Box,...
        ... handleToleranceNode2Box,...
        ... handleToleranceNode3Box,...
        ... handleToleranceNode1Component,...
        ... handleToleranceNode2Component,...
        ... handleToleranceNode3Component...
        ],...
    {...
        ... 'Initial Truss',...
        'Optimized Truss',...
        'Wall',...
        'Tolerance Region for Each Node (Box)',...
        'Tolerance Region for Each Node (Component)',...
        ... 'Tolerance Region for Node 1 (Box)',...
        ...'Tolerance Region for Node 2 (Box)',...
        ... 'Tolerance Region for Node 3 (Box)',...
        ... 'Tolerance Region for Node 1 (Component)',...
        ... 'Tolerance Region for Node 2 (Component)',...
        ...'Tolerance Region for Node 3 (Component)'...
        },...
    'FontSize',12);
measureComponent1 = componentSolutionSpace(1).Measure;
measureComponent2 = componentSolutionSpace(2).Measure;
measureComponent3 = componentSolutionSpace(3).Measure;
measureBox1 = prod(solutionSpaceBox(2,[1,2,3])-solutionSpaceBox(1,[1,2,3]));
measureBox2 = prod(solutionSpaceBox(2,[4,5,6])-solutionSpaceBox(1,[4,5,6]));
measureBox3 = prod(solutionSpaceBox(2,[7,8,9])-solutionSpaceBox(1,[7,8,9]));
sgtitle(sprintf('Volume Increases - Node 1: %.3gx ; Node 2: %.3gx ; Node 3: %.3gx',...
    measureComponent1/measureBox1,...
    measureComponent2/measureBox2,...
    measureComponent3/measureBox3));
axis('equal');
axis('vis3d');
camproj('perspective');
cameratoolbar; % better adjust angle/perspective
save_print_figure(gcf,[saveFolder,'TrussVisualization']);


%% 
algoDataBox = postprocess_sso_box_stochastic(problemDataBox,iterDataBox);
plot_sso_box_stochastic_metrics(algoDataBox,'SaveFolder',saveFolder);

algoData = postprocess_sso_component_stochastic(problemData,iterData);
plot_sso_component_stochastic_metrics(algoData,'SaveFolder',saveFolder);


%% Save and Stop Transcripting
save([saveFolder,'Data.mat']);
diary off;

