%test_component_hollow_sphere Component solution spaces for a sphere problem 
%   test_component_hollow_sphere computes a component solution spaces with 
%   for a sphere problem.
%
%   Copyright 2024 Eduardo Rodrigues Della Noce
%   SPDX-License-Identifier: Apache-2.0

%   Licensed under the Apache License, Version 2.0 (the "License");
%   you may not use this file except in compliance with the License.
%   You may obtain a copy of the License at
%   
%       http://www.apache.org/licenses/LICENSE-2.0
%   
%   Unless required by applicable law or agreed to in writing, software
%   distributed under the License is distributed on an "AS IS" BASIS,
%   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%   See the License for the specific language governing permissions and
%   limitations under the License.

%% Cleanup
fclose all;
close all;
clear all;
clc;
more off;
diary off;


%% debugging
rng(4);


%% Documentation / Archive
rngState = rng;
saveFolder = save_diary_files(mfilename);
goldenRatio = (1+sqrt(5))/2;
figureSize = [goldenRatio 1]*8.5;


%% function call
%
systemFunction = @truss_twelve_bar_3d_moving_node;
systemParameter = [100,210e3,795]; % [mm^2],[MPa],[mm^4]
%                         x1   y1   z1  x2   y2  z2  x3  y3   z3
designSpaceLowerBound = [0.5 -0.5 -1.0 0.1 -0.5 0.5 0.1 0.0 -1.0];
designSpaceUpperBound = [2.0  0.5  0.5 2.0  0.5 1.5 2.0 2.0  1.0];
Components = {[1,2,3]',[4,5,6]',[7,8,9]'};
%
performanceLowerLimit = -inf;
performanceUpperLimit = [nan repmat(250,1,13) ones(1,13)];
%                x1 y1 z1 x2  y2 z2 x3 y3 z3
initialDesign = [ 1  0  0  1 0.5  1  1  1  0];

figureIncludeLegendHeadline = false;
findOptimalSolution = true;


%% find optimum
bottomUpMapping = BottomUpMappingFunction(systemFunction,systemParameter);

if(findOptimalSolution)
    [nodePositionOptimal,displacementOptimal] = design_optimize_quantities_of_interest(...
        bottomUpMapping,...
        initialDesign,...
        designSpaceLowerBound,...
        designSpaceUpperBound,...
        @(performanceMeasure)[performanceMeasure(1)],...
        'InequalityConstraintFunction',@(performanceMeasure)[performanceMeasure(2:end)-performanceUpperLimit(2:end)],...
        'OptimizationMethodFunction',@optimization_fmincon_wrapper,...
        'OptimizationMethodOptions',{'Display','iter'});
else
    nodePositionOptimal = initialDesign;
    systemResponse = bottomUpMapping.response(nodePositionOptimal);
    displacementOptimal = systemResponse(1);
end


%% plot optimum and deformations
baseNode = [...
      0     0   0; % (1)
      0   0.5   1; % (2)
      0     1   0; % (3)
    nan nan nan; % (4)
    nan nan nan; % (5) 
    nan nan nan; % (6)
    2 0.5 0.5]; % (7)
fixedDegreesOfFreedom = [...
    true true true; % (1) 
    true true true; % (2)
    true true true; % (3)
    false false false; % (4)
    false false false; % (5)
    false false false; % (6)
    false false false]; % (7)
nodeForce = [...
    0 0     0; % (1)
    0 0     0; % (2)
    0 0     0; % (3)
    0 0     0; % (4)
    0 0     0; % (5)
    0 0     0; % (6)
    0 0 -1000]; % (7)
nodeElement = [...
    1 4; % (1)
    2 5; % (2)
    3 6; % (3)
    1 5; % (4)
    3 5; % CONFIRM WITH ZM
    2 4; % (6)
    2 6; % (7)
    4 5;
    4 6; % (8)
    4 7; % (9)
    5 6;
    5 7; % (10)
    6 7]; % (11)
elementCrossSectionArea = systemParameter(1); % [mm^2]
elementYoungsModulus = systemParameter(2); % [MPa]

nodePositionInitial = baseNode; % (3)
nodePositionInitial(4,:) = initialDesign(1:3);
nodePositionInitial(5,:) = initialDesign(4:6);
nodePositionInitial(6,:) = initialDesign(7:9);

nodePositionOptimized = baseNode; % (3)
nodePositionOptimized(4,:) = nodePositionOptimal(1:3);
nodePositionOptimized(5,:) = nodePositionOptimal(4:6);
nodePositionOptimized(6,:) = nodePositionOptimal(7:9);

[wallY,wallZ] = meshgrid(-0.5:1.5);
wallX = zeros(size(wallY));


% initial truss
figure;
hold all;
handleInitial = plot_truss_deformation(gcf,nodePositionInitial,nodeElement,'ColorUndeformed',[0.8 0.8 0.8],'MaximumLinewidth',4.0);
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleForce = quiver3(2,0.5,0.5,0,0,-0.5,'Color','r','LineWidth',4.0);
grid minor;
if(figureIncludeLegendHeadline)
    legend([handleInitial,handleWall,handleForce],...
        {'Initial Truss','Wall','Applied Force'},...
        'location','west');
end
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
camproj('perspective');
save_print_figure(gcf,[saveFolder,'InitialTruss']);


% initial + optimized truss
figure;
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleForce = quiver3(2,0.5,0.5,0,0,-0.5,'Color','r','LineWidth',4.0);
handleInitial = plot_truss_deformation(gcf,nodePositionInitial,nodeElement,'ColorUndeformed',[0.8 0.8 0.8],'MaximumLinewidth',4.0,'DisplacementScaleFactor',1000);
handleOptimal = plot_truss_deformation(gcf,nodePositionOptimized,nodeElement,'ColorUndeformed','b','MaximumLinewidth',4.0,'DisplacementScaleFactor',1000);
grid minor;
if(figureIncludeLegendHeadline)
    legend([...
            handleInitial,...
            handleWall,...
            handleForce,...
            handleOptimal,...
            ],...
        {...
            'Initial Truss',...
            'Initial Truss (Deformed)',...
            'Wall',...
            'Applied Force',...
            'Optimized Truss',...
            'Optimized Truss (Deformed)'...
            },...
        'FontSize',12);
end
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
camproj('perspective');
save_print_figure(gcf,[saveFolder,'InitialOptimizedTrussDeformation']);



% deformed trusses
nodeDisplacementInitial = ...
	truss_analysis(...
		nodePositionInitial,...
		fixedDegreesOfFreedom,...
		nodeForce,...
		nodeElement,...
		elementCrossSectionArea,...
		elementYoungsModulus);
nodeDisplacementOptimal = ...
    truss_analysis(...
	    nodePositionOptimized,...
	    fixedDegreesOfFreedom,...
	    nodeForce,...
	    nodeElement,...
	    elementCrossSectionArea,...
	    elementYoungsModulus);

figure;
[handleInitial,handleInitialDeformed] = plot_truss_deformation(gcf,nodePositionInitial,nodeElement,nodeDisplacementInitial,'ColorUndeformed',[0.8 0.8 0.8],'ColorDeformed','c','MaximumLinewidth',4.0,'DisplacementScaleFactor',1000);
[handleOptimal,handleOptimizedDeformed] = plot_truss_deformation(gcf,nodePositionOptimized,nodeElement,nodeDisplacementOptimal,'ColorUndeformed','b','ColorDeformed','m','MaximumLinewidth',4.0,'DisplacementScaleFactor',1000);
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleForce = quiver3(2,0.5,0.5,0,0,-0.5,'Color','r','LineWidth',4.0);
grid minor;
if(figureIncludeLegendHeadline)
    legend([...
            handleInitial,...
            handleInitialDeformed,...
            handleWall,...
            handleForce,...
            handleOptimal,...
            handleOptimizedDeformed...
            ],...
        {...
            'Initial Truss',...
            'Initial Truss (Deformed)',...
            'Wall',...
            'Applied Force',...
            'Optimized Truss',...
            'Optimized Truss (Deformed)'...
            },...
        'FontSize',12);
end
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
camproj('perspective');
save_print_figure(gcf,[saveFolder,'InitialOptimizedTrussDeformation']);


%% box opt
% update uppwer limit based on optimal value
performanceUpperLimit(1) = displacementOptimal*1.1;
designEvaluator = DesignEvaluatorBottomUpMapping(...
        bottomUpMapping,...
        performanceLowerLimit,...
        performanceUpperLimit);

tic
optionsBox = sso_stochastic_options('box',...
    'NumberSamplesPerIterationExploration',300,...
    'NumberSamplesPerIterationConsolidation',300,...
    'FixIterNumberExploration',true,...
    'FixIterNumberConsolidation',true,...
    'MaxIterExploration',30,...
    'MaxIterConsolidation',30,...
    'UseAdaptiveGrowthRate',false,...
    'GrowthRate',0.1,...
    'ApplyLeanness','never',...
    'TrimmingOperationOptions',{'PassesCriterion','full'},...
    'TrimmingOrderOptions',{'OrderPreference','score'});

[solutionSpaceBox,problemDataBox,iterDataBox] = sso_box_stochastic(designEvaluator,...
    nodePositionOptimal,designSpaceLowerBound,designSpaceUpperBound,optionsBox);
toc


%% component opt
tic
options = sso_stochastic_options('component',...
    'NumberSamplesPerIterationExploration',300,...
    'NumberSamplesPerIterationConsolidation',300,...
    'FixIterNumberExploration',true,...
    'FixIterNumberConsolidation',true,...
    'MaxIterExploration',30,...
    'MaxIterConsolidation',30,...
    ... 'CandidateSpaceConstructorExploration',@CandidateSpaceDelaunay,...
    ... 'CandidateSpaceConstructorConsolidation',@CandidateSpaceDelaunay,...
    ... 'TrimmingMethodFunction',@component_trimming_method_corner_box_removal,...
    'CandidateSpaceConstructorExploration',@CandidateSpaceConvexHull,...
    'CandidateSpaceConstructorConsolidation',@CandidateSpaceConvexHull,...
    'TrimmingMethodFunction',@component_trimming_method_planar_trimming,...
    ... 'TrimmingMethodOptions',{'ReferenceDesigns','boundary-center'},...
    'UseAdaptiveGrowthRate',false,...
    'GrowthRate',0.1,...
    'ApplyLeanness','never',...
    'UsePaddingSamplesInTrimming',true,...
    'UsePreviousEvaluatedSamplesConsolidation',false,...
    'UsePreviousPaddingSamplesConsolidation',false,...
    'TrimmingOperationOptions',{'PassesCriterion','reduced'},...
    'TrimmingOrderOptions',{'OrderPreference','score'});

[componentSolutionSpace,problemData,iterData] = sso_component_stochastic(designEvaluator,...
    nodePositionOptimal,designSpaceLowerBound,designSpaceUpperBound,Components,options);
toc


%% Plot Visualization
% initial truss + component solution spaces
figure;
hold all;
handleInitial = plot_truss_deformation(gcf,nodePositionInitial,nodeElement,'ColorUndeformed',[0.8 0.8 0.8],'MaximumLinewidth',4.0);
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleForce = quiver3(2,0.5,0.5,0,0,-0.5,'Color','r','LineWidth',4.0);
handleToleranceNode1Component = componentSolutionSpace(1).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode2Component = componentSolutionSpace(2).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode3Component = componentSolutionSpace(3).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
grid minor;
if(figureIncludeLegendHeadline)
    legend([handleInitial,handleWall,handleForce,handleToleranceNode1Component],...
        {'Initial Truss','Wall','Applied Force','Tolerance Region for Each Node (Component)'},...
        'location','west');
end
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
camproj('perspective');
save_print_figure(gcf,[saveFolder,'InitialTrussComponent']);

% initial truss + optimized truss + box solution space + component solution spaces
figure;
hold all;
handleInitial = plot_truss_deformation(gcf,nodePositionInitial,nodeElement,'ColorUndeformed',[0.8 0.8 0.8],'MaximumLinewidth',4.0);
handleOptimal = plot_truss_deformation(gcf,nodePositionOptimized,nodeElement,'ColorUndeformed','b','MaximumLinewidth',4.0);
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleForce = quiver3(2,0.5,0.5,0,0,-0.5,'Color','r','LineWidth',4.0);
handleToleranceNode1Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[1,2,3]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode2Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[4,5,6]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode3Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[7,8,9]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode1Component = componentSolutionSpace(1).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode2Component = componentSolutionSpace(2).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode3Component = componentSolutionSpace(3).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
grid minor;
if(figureIncludeLegendHeadline)
    legend([...
            handleInitial,...
            handleOptimal,...
            handleWall,...
            handleForce,...
            handleToleranceNode1Box,...
            handleToleranceNode1Component,...
            ... handleToleranceNode1Box,...
            ... handleToleranceNode2Box,...
            ... handleToleranceNode3Box,...
            ... handleToleranceNode1Component,...
            ... handleToleranceNode2Component,...
            ... handleToleranceNode3Component...
            ],...
        {...
            'Initial Truss',...
            'Optimized Truss',...
            'Wall',...
            'Applied Force',...
            'Tolerance Region for Each Node (Box)',...
            'Tolerance Region for Each Node (Component)',...
            ... 'Tolerance Region for Node 1 (Box)',...
            ... 'Tolerance Region for Node 2 (Box)',...
            ... 'Tolerance Region for Node 3 (Box)',...
            ... 'Tolerance Region for Node 1 (Component)',...
            ... 'Tolerance Region for Node 2 (Component)',...
            ... 'Tolerance Region for Node 3 (Component)'...
            },...
        'FontSize',12);
    measureComponent1 = componentSolutionSpace(1).Measure;
    measureComponent2 = componentSolutionSpace(2).Measure;
    measureComponent3 = componentSolutionSpace(3).Measure;
    measureBox1 = prod(solutionSpaceBox(2,[1,2,3])-solutionSpaceBox(1,[1,2,3]));
    measureBox2 = prod(solutionSpaceBox(2,[4,5,6])-solutionSpaceBox(1,[4,5,6]));
    measureBox3 = prod(solutionSpaceBox(2,[7,8,9])-solutionSpaceBox(1,[7,8,9]));
    sgtitle(sprintf('Volume Increases - Node 1: %.3gx ; Node 2: %.3gx ; Node 3: %.3gx',...
        measureComponent1/measureBox1,...
        measureComponent2/measureBox2,...
        measureComponent3/measureBox3));
end
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
camproj('perspective');
cameratoolbar; % better adjust angle/perspective
save_print_figure(gcf,[saveFolder,'InitialOptimizedTrussBoxComponent']);

% initial truss + box solution space + component solution spaces
figure;
hold all;
handleInitial = plot_truss_deformation(gcf,nodePositionInitial,nodeElement,'ColorUndeformed',[0.8 0.8 0.8],'MaximumLinewidth',4.0);
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleForce = quiver3(2,0.5,0.5,0,0,-0.5,'Color','r','LineWidth',4.0);
handleToleranceNode1Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[1,2,3]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode2Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[4,5,6]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode3Box = plot_design_box_3d(gcf,solutionSpaceBox(:,[7,8,9]),'FaceAlpha',0.2,'FaceColor','c');
handleToleranceNode1Component = componentSolutionSpace(1).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode2Component = componentSolutionSpace(2).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode3Component = componentSolutionSpace(3).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
grid minor;
if(figureIncludeLegendHeadline)
    legend([...
            handleInitial,...
            handleWall,...
            handleForce,...
            handleToleranceNode1Box,...
            handleToleranceNode1Component,...
            ... handleToleranceNode1Box,...
            ... handleToleranceNode2Box,...
            ... handleToleranceNode3Box,...
            ... handleToleranceNode1Component,...
            ... handleToleranceNode2Component,...
            ... handleToleranceNode3Component...
            ],...
        {...
            'Initial Truss',...
            'Wall',...
            'Applied Force',...
            'Tolerance Region for Each Node (Box)',...
            'Tolerance Region for Each Node (Component)',...
            ... 'Tolerance Region for Node 1 (Box)',...
            ... 'Tolerance Region for Node 2 (Box)',...
            ... 'Tolerance Region for Node 3 (Box)',...
            ... 'Tolerance Region for Node 1 (Component)',...
            ... 'Tolerance Region for Node 2 (Component)',...
            ... 'Tolerance Region for Node 3 (Component)'...
            },...
        'FontSize',12);
    measureComponent1 = componentSolutionSpace(1).Measure;
    measureComponent2 = componentSolutionSpace(2).Measure;
    measureComponent3 = componentSolutionSpace(3).Measure;
    measureBox1 = prod(solutionSpaceBox(2,[1,2,3])-solutionSpaceBox(1,[1,2,3]));
    measureBox2 = prod(solutionSpaceBox(2,[4,5,6])-solutionSpaceBox(1,[4,5,6]));
    measureBox3 = prod(solutionSpaceBox(2,[7,8,9])-solutionSpaceBox(1,[7,8,9]));
    sgtitle(sprintf('Volume Increases - Node 1: %.3gx ; Node 2: %.3gx ; Node 3: %.3gx',...
        measureComponent1/measureBox1,...
        measureComponent2/measureBox2,...
        measureComponent3/measureBox3));
end
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
camproj('perspective');
save_print_figure(gcf,[saveFolder,'InitialTrussBoxComponent']);


% initial truss + sample trusses + component solution space
nRandomTruss = 5;
randomTrussMovingNode = candidate_space_sampling_individual_feasible(componentSolutionSpace,Components,nRandomTruss);

figure;
hold all;
handleInitial = plot_truss_deformation(gcf,nodePositionInitial,nodeElement,'ColorUndeformed',[0.8 0.8 0.8],'MaximumLinewidth',4.0);
handleWall = surf(wallX,wallY,wallZ,'FaceColor',[0.7 0.7 0.7],'EdgeColor','none','FaceAlpha',0.9);
handleForce = quiver3(2,0.5,0.5,0,0,-0.5,'Color','r','LineWidth',4.0);
handleToleranceNode1Component = componentSolutionSpace(1).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode2Component = componentSolutionSpace(2).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
handleToleranceNode3Component = componentSolutionSpace(3).plot_candidate_space(gcf,'FaceAlpha',0.2,'FaceColor','g');
for i=1:nRandomTruss
    randomNodePosition = nodePositionInitial;
    randomNodePosition(4,:) = randomTrussMovingNode(i,[1,2,3]);
    randomNodePosition(5,:) = randomTrussMovingNode(i,[4,5,6]);
    randomNodePosition(6,:) = randomTrussMovingNode(i,[7,8,9]);
    handleRandom(i) = plot_truss_deformation(gcf,randomNodePosition,nodeElement,'ColorUndeformed',rand(1,3),'MaximumLinewidth',3.0);
end
grid minor;
if(figureIncludeLegendHeadline)
    legend([...
            handleInitial,...
            handleWall,...
            handleForce,...
            handleToleranceNode1Component,...
            ... handleToleranceNode1Component,...
            ... handleToleranceNode2Component,...
            ... handleToleranceNode3Component...
            ],...
        {...
            'Initial Truss',...
            'Wall',...
            'Applied Force',...
            'Tolerance Region for Each Node (Component)',...
            ... 'Tolerance Region for Node 1 (Component)',...
            ... 'Tolerance Region for Node 2 (Component)',...
            ... 'Tolerance Region for Node 3 (Component)'...
            },...
        'FontSize',12);
end
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
camproj('perspective');
save_print_figure(gcf,[saveFolder,'InitialRandomTrussComponent']);


%% plot candidate spaces samples
% candidate space 1
designSample = componentSolutionSpace(1).DesignSampleDefinition;
labelSample = componentSolutionSpace(1).IsInsideDefinition;
figure;
componentSolutionSpace(1).plot_candidate_space(gcf,'EdgeColor','none','FaceColor','g','FaceAlpha',0.5,'Linewidth',2.0);
hold all;
plot3(designSample(labelSample,1),designSample(labelSample,2),designSample(labelSample,3),'g.');
plot3(designSample(~labelSample,1),designSample(~labelSample,2),designSample(~labelSample,3),'r.');
grid minor;
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
view(3);
save_print_figure(gcf,[saveFolder,'ComponentSpace1TrimmingPlot']);

% candidate space 2
designSample = componentSolutionSpace(2).DesignSampleDefinition;
labelSample = componentSolutionSpace(2).IsInsideDefinition;
figure;
componentSolutionSpace(2).plot_candidate_space(gcf,'EdgeColor','none','FaceColor','g','FaceAlpha',0.5,'Linewidth',2.0);
hold all;
plot3(designSample(labelSample,1),designSample(labelSample,2),designSample(labelSample,3),'g.');
plot3(designSample(~labelSample,1),designSample(~labelSample,2),designSample(~labelSample,3),'r.');
grid minor;
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
view(3);
save_print_figure(gcf,[saveFolder,'ComponentSpace2TrimmingPlot']);

% candidate space 3
designSample = componentSolutionSpace(3).DesignSampleDefinition;
labelSample = componentSolutionSpace(3).IsInsideDefinition;
figure;
componentSolutionSpace(3).plot_candidate_space(gcf,'EdgeColor','none','FaceColor','g','FaceAlpha',0.5,'Linewidth',2.0);
hold all;
plot3(designSample(labelSample,1),designSample(labelSample,2),designSample(labelSample,3),'g.');
plot3(designSample(~labelSample,1),designSample(~labelSample,2),designSample(~labelSample,3),'r.');
grid minor;
xlabel('x');
ylabel('y');
zlabel('z');
axis('equal');
axis('vis3d');
view(3);
save_print_figure(gcf,[saveFolder,'ComponentSpace3TrimmingPlot']);


%% 
algoDataBox = postprocess_sso_box_stochastic(problemDataBox,iterDataBox);
plot_sso_box_stochastic_metrics(algoDataBox,'SaveFolder',saveFolder,'CloseFigureAfterSaving',true);

algoData = postprocess_sso_component_stochastic(problemData,iterData);
plot_sso_component_stochastic_metrics(algoData,'SaveFolder',saveFolder,'CloseFigureAfterSaving',true);


%% Save and Stop Transcripting
save([saveFolder,'Data.mat']);
diary off;

